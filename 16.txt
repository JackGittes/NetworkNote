计算机网络原理笔记 16
数据链路控制（三）
作者：赵明心    日期：2019/02/25

网络中常见的是检错重发机制，通过正向应答和超时重发来实现这个过程。为什么纠错用的少？

4.4.2   纠错码和检错码
    1、码字codeword
    一个帧有m个数据位，r个校验位，称为n位码字（n=m+r）。
    希望r尽可能短，同时希望检错率尽可能高，而且希望m不管多少位，r的位数固定，这样可以简化协议控制信息。

    2、纠错码error-correcting code
    加入足够多的冗余位，使接收方不仅知道差错发生，并知道哪些位发生差错。

    3、检错码error-detecting code
    加入冗余位，使接收方知道有差错发生，但不知道什么差错，然后请求重发。

    奇偶校验码为了检验一位差错需要加一位冗余，海明码为了纠正7位数据的1位差错，需要加4位。很明显，纠错码比检错码更长。

4.4.3   海明定理
    1、海明距离
    （1）两个编码的海明距离：两个编码不相同位的个数
    （2）编码方案的海明距离：编码方案中任两个海明码距离的最小值
    （3）例：0000000000和0000011111的海明距离为5
    2、海明定理
    （1）为检测d位错，编码方案的海明距离应至少为d+1
    （2）当发生d位错时，不会由一种合法编码变为另一种合法编码
    （3）为纠正d位错，编码方案的海明距离应至少为2d+1
    当发生d位错时，出错编码仍然最接近于原始的正确编码。

    ASCII码的编码海明距离是多少呢？连续ASCII的海明距离是1。接收方来说，判定编码是否出错的唯一依据是该编码是否是合法编码。

    差错码举例
    1、奇偶校验码
    （1）在数据后添加一个奇偶位
    例：使用偶校验（“1”的个数为偶数）
    10110101 ——> 101101011
    10110001 ——> 101100010

    （2）若接收方收到的字节奇偶结果不正确，就可以知道传输中发生了错误。
    （3）增加奇偶校验位后海明距离由1变为2，因此可以检查出一位二进制位的查错

    接收方接受到一个非法编码的时候，即认为接收出现了错误，奇偶校验码的任意一位发生错误，是可以检测出错误的（仅限于1位错）。

    纠错例子：
    一种编码方案中只有4种合法编码：
    0000000000
    0000011111
    1111100000
    1111111111
    此编码的海明距离是5，那么需要进行纠错的话，出错的时候找海明距离最近的正确编码，这样可以计算出来，距离（1）为2，距离（2）为7，距离（3）为3，距离（4）为8。所以恢复为（1）。纠错的直接影响是信道利用率低，要增加很多冗余位。

    数据链路层一般不使用奇偶校验，因为检错率太低，根据网络错误连续突发的特点，奇偶校验很难发现这种错误。实际使用多的是CRC算法。

4.4.4   循环冗余码（CRC）
    1、循环冗余码（CRC码，多项式编码）
    110001，表示成多项式x^5+x^4+1
    2、生成多项式G(x)
    （1）发方、收方事前约定
    （2）生成多项式的高位和低位必须为1
    （3）生成多项式必须比传输信息对应的多项式短。
    3、CRC校验基本思想：
    CRC码（即校验和）加在帧尾，使带CRC码的帧的多项式能被G(x)除尽；接收方接收时，用G(x)去除它，若有余数，则传输出错。

    一般数据链路层协议会指定生成多项式，使用协议的所有节点都会事先约定好。发送的时候让m和r满足一定规则，接收方检验是否接受到的m位和r位满足这个规则，满足则认为无错，不满足肯定出错。

    CRC码计算方法：
    （1）设G(x)为r阶，在帧的末尾加r个0，使帧为m+r位，相应多项式为x^rM(x);
    （2）按模2除法用对应于G(x)的位串去除对应于x^rM(x)的位串；
    （3）按模2减法从对应于x^rM(x)的位串中减去余数（等于或小于r位），结果就是要传送的带校验和的多项式T(x)
        T(x)=x^rM(x)+[x^rM(x) Mod2 G(x)]

    数据链路层使用最多的就是循环冗余校验法，信息加在尾部的原因？加在尾部可以做到边计算边发送，因为前面的位数没有改变，同时对于接收方来说，可以直接边接收边校验。CRC适合于用硬件实现，提高了检错效率。

    循环冗余校验的检错效率是多少呢？出现了什么问题的时候循环冗余无法校验？
    循环冗余校验法CRC码计算方法：
    1、CRC的检错能力
    （1）发送：T(x)；接收：T(x)+E(x);
    （2）余数((T(x)+E(x))/G(x))=0+余数(E(x)/G(x))
    （3）若余数(E(x)/G(x))=0，则差错不能发现；否则，可以发现。
    2、四个多项式已经成为国际标准
    （1）CRC-12=X^12+X^11+X^3+X^2+X+1
    （2）CRC-16=X^16+X^15+X^2+1
    （3）CRC-CCITT=X^16+X^12+X^5+1
    （4）
    3、硬件实现CRC校验

    数据链路层协议用的最多的是最后一个32位生成多项式，生成多项式要求最高位和最低位为1，同时要求生成多项式比待传数据短，从原始数据将，难以保证传输数据一定比32位长，但是从数据链路层来说，一般是长的。TCP增加20字节的头，网络层增加20字节的头，就算是没有数据，也比32位长。四个国际标准中，越往下检错率越高。这些多项式中，12阶一般不使用，因为12不是字节的整数倍，因为网络的末端一般都是计算机，其处理单元都是字节，所以最好要整除字节位宽。

    检错码在高层，网络层和传输层是不使用的，而使用校验和方法。

4.4.5   校验和（checksum）
    实际检验和算法可能和这里介绍的略有差异。
    1、检验字段初值为0
    2、数据拆分成与检验字段等长的分片，不足部分补0
    3、将所有分片逐位取反，并连续累加，丢弃最高进位
    4、计算结果置入检验字段
    5、接收端执行相同的过程，并将计算结果和传输过来的检验和进行比较以决定数据是否出现差错。

    适用于高层协议，如IP、TCP、UDP等。

    检验和算法举例：
    1、待传输数据为：10010100，01110110，1100
    2、计算过程为：
    （1）~(10010100)+~(01110110)=11110100
    （2）11110100+~(11000000)=00110011
    3、带校验和的传输数据为：
    10010100,01110110,1100 00110011

    思考：数据链路层为什么不用校验和？为什么高层不使用CRC？校验和算法的校验位放在前后影响大不大？

    高层的协议数据单元，只有前面，没有尾部，因为校验和放在前后对效率影响不大。校验和出错但无法检出的情况比较多，多于CRC。但是校验和检测不出来的情况是网络中比较少出现的。连续错的情况，检验和的检错率还是比较高的。

    从检错率来说，CRC的检错率较高，但是从高层来说，CRC主要是除法，校验和主要是累加，校验和算法的运算效率高，CRC更多需要从硬件实现来弥补计算效率差的问题，而高层一般只能软件实现，所以只能用检验和算法。

    数据链路层用的都是CRC，TCP\IP\UDP都是校验和。纠错码此处略去，因为实际网络很少使用。

    差错控制每一层都需要解决。

4.5 流量控制
    站在数据链路层，数据是如何发送的？以单工通信为例：

       发送方                             接收方
    
    主机A   AP1                        主机B   AP2          高层
         |                                ^
         |               帧               |              数据链路层
         缓存——————————数据链路————————————| 缓存

    上层发送数据到数据链路层的时候，数据链路层把数据构成帧，数据是从上层推送到下层的，而不是从下层拉下来的。上层数据递交给数据链路的时候，需要构成帧，要注意帧需要存在缓存中。因为数据在传输中如果出现了问题，需要重发，而数据只能以推送形式到达数据链路层，如果不缓存，一旦出错则无法重新发送。第二个问题是，数据通信过程当中，有可能有多个进程要求发送数据，所以必须缓存排队，再者即便是排在了帧队列队首，也有可能因为信道问题需要等待。

    那么什么情况下需要将缓存中的帧删除呢？确认发送成功的时候！只要确认该数据已经发送成功，就可以把帧从缓存中删除了。接收方也需要有缓存，因为数据提交的时候必须正确、按序，所以需要在缓存中进行校验，并按照顺序进行排列。再有，数据在发送方发送的时候可能发生了分段，前1、2、3帧按顺序到达的时候，如果第4帧才能组成一个服务数据单元，则必须等待第4个帧到达，组成完整的SDU之后才能提交到高层。


